<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>SIG</title>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;line-height:1.35}
  body{margin:0;padding:24px;background:#0b0f14;color:#e7eef7}
  .wrap{max-width:1020px;margin:0 auto}
  h1{margin:0 0 14px;font-size:22px}
  .card{background:#121a24;border:1px solid #213042;border-radius:14px;padding:16px;box-shadow:0 6px 20px rgba(0,0,0,.25)}
  label{font-size:12px;color:#a9b7c7;display:block;margin:0 0 6px}
  input,textarea,button,select{width:100%;box-sizing:border-box;border-radius:10px;border:1px solid #2a3b52;background:#0f1520;color:#e7eef7;padding:10px 12px;font:inherit}
  textarea{min-height:110px;resize:vertical}
  button{cursor:pointer;background:#1b2a3d;border-color:#2f4764}
  button:hover{background:#22344b}
  select{cursor:pointer}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .tabs{display:flex;gap:10px;margin:14px 0}
  .tab{flex:1;padding:10px;border-radius:10px;border:1px solid #2a3b52;background:#0f1520;color:#e7eef7;cursor:pointer;text-align:center}
  .tab.active{background:#1b2a3d;border-color:#2f4764}
  .row{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:860px){.row2{grid-template-columns:1fr 1fr}}
  @media(min-width:960px){.row3{grid-template-columns:1fr 1fr 1fr}}
  .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
  .actions button{width:auto;padding:10px 14px}
  .small{font-size:12px;color:#a9b7c7;margin-top:8px}
  .ok{color:#73e6a5}
  .warn{color:#ffcc66}
  .err{color:#ff7b7b}
  .hint{color:#a9b7c7;font-size:12px;margin-top:6px}
  .hr{height:1px;background:#213042;margin:14px 0}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #2a3b52;background:#0f1520;color:#a9b7c7;font-size:12px}
  .hidden{display:none!important}
  details{border:1px solid #213042;border-radius:12px;padding:10px;background:#0f1520}
  summary{cursor:pointer;color:#e7eef7}
  .grid2{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:860px){.grid2{grid-template-columns:1fr 1fr}}
  .grid3{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:860px){.grid3{grid-template-columns:1fr 1fr 1fr}}
</style>
</head>
<body>
<div class="wrap">
  <h1>SIG <span class="pill" id="inspectorBadge">Inspector: off</span></h1>

  <div class="card">
    <div class="row row2">
      <div>
        <label>Shared Key</label>
        <input id="key" class="mono" autocomplete="off" spellcheck="false">
        <div class="hint">Same key must be used to decrypt.</div>
      </div>
      <div>
        <label>Version</label>
        <div class="tabs" style="margin:0">
          <button class="tab active" id="tabSIG1" type="button">SIG1</button>
          <button class="tab" id="tabSIG2" type="button">SIG2</button>
          <button class="tab" id="tabSIG3" type="button">SIG3</button>
        </div>
      </div>
    </div>

    <!-- ===================== SIG1 ===================== -->
    <div id="panelSIG1" style="margin-top:14px;">
      <div class="tabs">
        <button class="tab active" id="tabSIG1Dec" type="button">Decrypt</button>
        <button class="tab" id="tabSIG1Enc" type="button">Encrypt</button>
      </div>

      <div id="sig1Dec">
        <label>Payload</label>
        <textarea id="sig1Payload" class="mono" spellcheck="false"></textarea>

        <div class="actions">
          <button id="sig1BtnDec" type="button">Decrypt</button>
          <button id="sig1BtnClear" type="button">Clear</button>
          <button id="sig1BtnCopyClean" type="button">Copy Clean</button>
        </div>

        <label style="margin-top:12px;">Raw Output</label>
        <textarea id="sig1OutRaw" class="mono" readonly></textarea>

        <label style="margin-top:12px;">Cleaned Output (X â†’ space)</label>
        <textarea id="sig1OutClean" readonly></textarea>

        <div id="sig1Status" class="small"></div>
      </div>

      <div id="sig1Enc" style="display:none;">
        <label>Plaintext (Aâ€“Z only; use X for spaces)</label>
        <textarea id="sig1Plain" class="mono" spellcheck="false"></textarea>

        <div class="actions">
          <button id="sig1BtnEnc" type="button">Encrypt</button>
          <button id="sig1BtnNonce" type="button">New Nonce</button>
          <button id="sig1BtnCopyPayload" type="button">Copy Payload</button>
        </div>

        <div class="row row2" style="margin-top:12px;">
          <div>
            <label>Nonce</label>
            <input id="sig1Nonce" class="mono" maxlength="6" spellcheck="false">
          </div>
          <div>
            <label>Payload</label>
            <input id="sig1PayloadOut" class="mono" readonly>
          </div>
        </div>

        <label style="margin-top:12px;">Ciphertext</label>
        <textarea id="sig1Cipher" class="mono" readonly></textarea>

        <div id="sig1StatusEnc" class="small"></div>
      </div>
    </div>

    <!-- ===================== SIG2 (embedded) ===================== -->
    <div id="panelSIG2" style="display:none;margin-top:14px;">
      <div class="tabs">
        <button class="tab active" id="tabSIG2Dec" type="button">Decrypt</button>
        <button class="tab" id="tabSIG2Enc" type="button">Encrypt</button>
      </div>

      <div id="sig2Dec">
        <label>Payload</label>
        <textarea id="sig2Payload" class="mono" spellcheck="false"></textarea>

        <div class="row row2" style="margin-top:12px;">
          <div>
            <label>Salt (optional)</label>
            <input id="sig2SaltDec" class="mono" spellcheck="false">
          </div>
          <div>
            <label>Detected Mode</label>
            <input id="sig2ModeDec" class="mono" readonly>
          </div>
        </div>

        <div class="actions">
          <button id="sig2BtnDec" type="button">Decrypt</button>
          <button id="sig2BtnClear" type="button">Clear</button>
          <button id="sig2BtnCopyPlain" type="button">Copy Output</button>
        </div>

        <label style="margin-top:12px;">Output</label>
        <textarea id="sig2Out" readonly></textarea>

        <div id="sig2Status" class="small"></div>

        <div class="hint" style="margin-top:10px;">
          SIG2 supports letters, digits, space, and common punctuation. Provide the correct salt if used.
        </div>
      </div>

      <div id="sig2Enc" style="display:none;">
        <label>Plaintext</label>
        <textarea id="sig2Plain" spellcheck="false"></textarea>

        <div class="row row2" style="margin-top:12px;">
          <div>
            <label>Salt (optional)</label>
            <input id="sig2SaltEnc" class="mono" spellcheck="false">
          </div>
          <div>
            <label>Mode</label>
            <select id="sig2ModeEnc">
              <option value="A">A - Normal</option>
              <option value="B">B - Aggressive stepping</option>
              <option value="C">C - Alt reflector</option>
              <option value="D">D - Emoji/Symbol</option>
            </select>
          </div>
        </div>

        <div class="actions" style="margin-top:12px;">
          <button id="sig2BtnEnc" type="button">Encrypt</button>
          <button id="sig2BtnNonce" type="button">New Nonce</button>
          <button id="sig2BtnCopyPayload" type="button">Copy Payload</button>
        </div>

        <div class="row row2" style="margin-top:12px;">
          <div>
            <label>Nonce</label>
            <input id="sig2Nonce" class="mono" maxlength="6" spellcheck="false">
          </div>
          <div>
            <label>Tag</label>
            <input id="sig2Tag" class="mono" readonly maxlength="6">
          </div>
        </div>

        <label style="margin-top:12px;">Payload</label>
        <input id="sig2PayloadOut" class="mono" readonly>

        <label style="margin-top:12px;">Ciphertext</label>
        <textarea id="sig2Cipher" class="mono" readonly></textarea>

        <div id="sig2StatusEnc" class="small"></div>
      </div>
    </div>

    <!-- ===================== SIG3 (draft engine) ===================== -->
    <div id="panelSIG3" style="display:none;margin-top:14px;">
      <div class="tabs">
        <button class="tab active" id="tabSIG3Dec" type="button">Decrypt</button>
        <button class="tab" id="tabSIG3Enc" type="button">Encrypt</button>
      </div>

      <!-- SIG3 Decrypt -->
      <div id="sig3Dec">
        <div class="row row3">
          <div>
            <label>Mode</label>
            <select id="sig3ModeDec">
              <option value="A">A (standard)</option>
              <option value="B">B (aggressive stepping)</option>
              <option value="C">C (alt reflector)</option>
              <option value="D">D (emoji/symbol alphabet)</option>
            </select>
          </div>
          <div>
            <label>Salt (optional)</label>
            <input id="sig3SaltDec" class="mono" autocomplete="off" spellcheck="false">
          </div>
          <div>
            <label>Hardening</label>
            <select id="sig3KdfDec">
              <option value="0">0 (legacy / fastest)</option>
              <option value="1">1 (fast)</option>
              <option value="2" selected>2 (normal)</option>
              <option value="3">3 (heavy)</option>
            </select>
          </div>
        </div>

        <label style="margin-top:10px;">Payload (can be embedded in other text; decryptor extracts it)</label>
        <textarea id="sig3Payload" class="mono" spellcheck="false"></textarea>

        <div class="actions">
          <button id="sig3BtnDec" type="button">Decrypt</button>
          <button id="sig3BtnClear" type="button">Clear</button>
          <button id="sig3BtnCopyPlain" type="button">Copy Output</button>
        </div>

        <label style="margin-top:12px;">Output</label>
        <textarea id="sig3Out" readonly></textarea>

        <div id="sig3Status" class="small"></div>
        <div class="hint" style="margin-top:10px;">
          SIG3 draft supports: decoy mode, time lock, packed ciphertext, stego wrapping, inspector, and key hardening.
        </div>
      </div>

      <!-- SIG3 Encrypt -->
      <div id="sig3Enc" style="display:none;">
        <div class="row row3">
          <div>
            <label>Mode</label>
            <select id="sig3ModeEnc">
              <option value="A">A (standard)</option>
              <option value="B">B (aggressive stepping)</option>
              <option value="C">C (alt reflector)</option>
              <option value="D">D (emoji/symbol alphabet)</option>
            </select>
          </div>
          <div>
            <label>Salt (optional)</label>
            <input id="sig3SaltEnc" class="mono" autocomplete="off" spellcheck="false">
          </div>
          <div>
            <label>Hardening</label>
            <select id="sig3KdfEnc">
              <option value="0">0 (legacy / fastest)</option>
              <option value="1">1 (fast)</option>
              <option value="2" selected>2 (normal)</option>
              <option value="3">3 (heavy)</option>
            </select>
          </div>
        </div>

        <div class="row row2" style="margin-top:10px;">
          <div>
            <label>Time-lock (earliest date to decrypt) â€” optional</label>
            <input id="sig3DateEnc" class="mono" placeholder="YYYYMMDD" maxlength="8" spellcheck="false">
            <div class="hint">Leave blank for no time lock.</div>
          </div>
          <div>
            <label>Output Format</label>
            <select id="sig3OutFmt">
              <option value="standard" selected>Standard (readable)</option>
              <option value="packed">Packed (shorter ciphertext segment)</option>
            </select>
          </div>
        </div>

        <label style="margin-top:10px;">Plaintext (real)</label>
        <textarea id="sig3Plain" spellcheck="false"></textarea>

        <details style="margin-top:10px;">
          <summary>Decoy Mode (optional)</summary>
          <div class="grid2" style="margin-top:10px;">
            <div>
              <label>Decoy Plaintext</label>
              <textarea id="sig3PlainDecoy" spellcheck="false"></textarea>
            </div>
            <div>
              <label>Decoy Salt (optional)</label>
              <input id="sig3SaltDecoy" class="mono" autocomplete="off" spellcheck="false">
            </div>
          </div>
        </details>

        <details style="margin-top:10px;">
          <summary>Stego Output (optional)</summary>
          <div class="grid2" style="margin-top:10px;">
            <div>
              <label>Style</label>
              <select id="sig3StegoStyle">
                <option value="none" selected>None</option>
                <option value="version">Version string</option>
                <option value="coords">Coordinates</option>
                <option value="commit">Commit hash</option>
              </select>
            </div>
            <div>
              <label>Stego Output</label>
              <textarea id="sig3StegoOut" class="mono" readonly></textarea>
            </div>
          </div>
        </details>

        <div class="actions">
          <button id="sig3BtnEnc" type="button">Encrypt</button>
          <button id="sig3BtnNonce" type="button">New Nonce</button>
          <button id="sig3BtnCopyPayload" type="button">Copy Payload</button>
          <button id="sig3BtnCopyStego" type="button">Copy Stego</button>
        </div>

        <div class="row row3" style="margin-top:12px;">
          <div>
            <label>Nonce</label>
            <input id="sig3Nonce" class="mono" maxlength="6" spellcheck="false">
          </div>
          <div>
            <label>Tag (real)</label>
            <input id="sig3Tag" class="mono" maxlength="6" readonly>
          </div>
          <div>
            <label>Tag (decoy)</label>
            <input id="sig3TagDecoy" class="mono" maxlength="6" readonly>
          </div>
        </div>

        <label style="margin-top:12px;">Payload</label>
        <input id="sig3PayloadOut" class="mono" readonly>

        <div id="sig3StatusEnc" class="small"></div>
      </div>
    </div>

    <!-- Inspector (SIG3 only) -->
    <div id="inspectorPanel" class="hidden" style="margin-top:14px;">
      <details open>
        <summary>Inspector (Ctrl + Shift + S)</summary>
        <div class="grid3" style="margin-top:10px;">
          <div>
            <label>Ignore time lock (decrypt anyway)</label>
            <select id="insIgnoreTime">
              <option value="0" selected>No</option>
              <option value="1">Yes</option>
            </select>
          </div>
          <div>
            <label>Show internal debug text</label>
            <select id="insShowDebug">
              <option value="0" selected>No</option>
              <option value="1">Yes</option>
            </select>
          </div>
          <div>
            <label>Today (local)</label>
            <input id="insToday" class="mono" readonly>
          </div>
        </div>
        <div class="hr"></div>
        <label>Last decrypt parse / debug</label>
        <textarea id="insDebug" class="mono" readonly style="min-height:140px;"></textarea>
      </details>
    </div>

  </div>
</div>

<script>
/* =========================
   Shared utilities
========================= */
const A_CODE = "A".charCodeAt(0);
const el = (id)=>document.getElementById(id);

function nonce6(){
  const b=new Uint8Array(6);
  crypto.getRandomValues(b);
  let s="";
  for(let i=0;i<6;i++) s += String.fromCharCode(A_CODE + (b[i]%26));
  return s;
}
function todayYYYYMMDD(){
  const d=new Date();
  const y=d.getFullYear();
  const m=String(d.getMonth()+1).padStart(2,"0");
  const da=String(d.getDate()).padStart(2,"0");
  return `${y}${m}${da}`;
}
function copyText(v){
  if(!v) return;
  navigator.clipboard.writeText(v).catch(()=>{});
}
async function sha256Bytes(str){
  const data=new TextEncoder().encode(str);
  const digest=await crypto.subtle.digest("SHA-256", data);
  return new Uint8Array(digest);
}
function bytesToHex(bytes){
  let out="";
  for(const b of bytes) out += b.toString(16).padStart(2,"0");
  return out;
}
function cleanAZ(s){ return (s||"").toUpperCase().replace(/[^A-Z]/g,""); }
function isHex6(s){ return /^[0-9A-F]{6}$/.test((s||"").toUpperCase()); }
function isDate8(s){ return /^[0-9]{8}$/.test(s||""); }
function extractPayload(text){
  const t=(text||"").trim();
  const idx1=t.toUpperCase().indexOf("SIG1.");
  const idx3=t.toUpperCase().indexOf("SIG3");
  let idx=-1;
  if(idx1>=0 && idx3>=0) idx=Math.min(idx1,idx3);
  else idx = (idx1>=0?idx1:idx3);
  if(idx<0) return t.replace(/\s+/g,"");
  return t.slice(idx).replace(/\s+/g,"");
}

/* =========================
   Shared PRNG stream helpers
========================= */
async function* byteStreamFromBytes(seedBytes){
  let block = seedBytes;
  while(true){
    for(let i=0;i<block.length;i++) yield block[i];
    block = await crypto.subtle.digest("SHA-256", block).then(b=>new Uint8Array(b));
  }
}
async function* byteStreamFromString(seedStr){
  let block = await sha256Bytes(seedStr);
  while(true){
    for(let i=0;i<block.length;i++) yield block[i];
    block = await crypto.subtle.digest("SHA-256", block).then(b=>new Uint8Array(b));
  }
}

/* =========================
   SIG1
========================= */
const mod26=(n)=> (n%26+26)%26;
const toIdx26=(c)=> c.charCodeAt(0)-A_CODE;
const toCh26=(i)=> String.fromCharCode(A_CODE+i);

async function buildSIG1(key, nonce){
  if(!key || !key.trim()) throw new Error("Key required.");
  const stream = byteStreamFromString(`SIG1|${key.trim()}|${nonce}`);
  const nextByte = async()=> (await stream.next()).value;

  async function randInt(n){
    const lim = Math.floor(256/n)*n;
    while(true){
      const b = await nextByte();
      if(b < lim) return b % n;
    }
  }
  async function makeRotor(){
    const arr = Array.from({length:26},(_,i)=>i);
    for(let i=25;i>0;i--){
      const j = await randInt(i+1);
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }
  const r0=await makeRotor(), r1=await makeRotor(), r2=await makeRotor();
  const inv=(r)=>{ const ir=new Array(26); for(let i=0;i<26;i++) ir[r[i]]=i; return ir; };
  const ir0=inv(r0), ir1=inv(r1), ir2=inv(r2);

  async function makeReflector(){
    const ref = new Array(26).fill(-1);
    const u = Array.from({length:26},(_,i)=>i);
    while(u.length){
      const a = u.splice(await randInt(u.length),1)[0];
      if((await randInt(100))<20 || !u.length){ ref[a]=a; continue; }
      const b = u.splice(await randInt(u.length),1)[0];
      ref[a]=b; ref[b]=a;
    }
    return ref;
  }
  const ref = await makeReflector();
  const o0=(await nextByte())%26, o1=(await nextByte())%26, o2=(await nextByte())%26;
  return {r0,r1,r2,ir0,ir1,ir2,ref,o0,o1,o2};
}
function stepSIG1(s){
  s.o2 = (s.o2+1)%26;
  if(s.o2===0){
    s.o1 = (s.o1+1)%26;
    if(s.o1===0) s.o0 = (s.o0+1)%26;
  }
}
function rotorFwd26(x, rotor, off){
  const y = rotor[mod26(x+off)];
  return mod26(y-off);
}
function rotorInv26(x, invRotor, off){
  const y = invRotor[mod26(x+off)];
  return mod26(y-off);
}
function xformSIG1(x, s){
  x = rotorFwd26(x,s.r0,s.o0);
  x = rotorFwd26(x,s.r1,s.o1);
  x = rotorFwd26(x,s.r2,s.o2);
  x = s.ref[x];
  x = rotorInv26(x,s.ir2,s.o2);
  x = rotorInv26(x,s.ir1,s.o1);
  x = rotorInv26(x,s.ir0,s.o0);
  return x;
}
function cleanSIG1Text(s){ return (s||"").toUpperCase().replace(/[^A-Z]/g,""); }
async function sig1Crypt(key, nonce, text){
  const s=await buildSIG1(key, nonce);
  const input=cleanSIG1Text(text);
  let out="";
  for(const ch of input){
    stepSIG1(s);
    out += toCh26(xformSIG1(toIdx26(ch), s));
  }
  return out;
}

/* =========================
   SIG2 (embedded from your code)
========================= */
const SIG2_MODES = {
  A: { alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789.,?!:;'-()/@#&", mStepDiv: 7, lStepDiv: 11, roffStep: 1 },
  B: { alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789.,?!:;'-()/@#&", mStepDiv: 3, lStepDiv: 5,  roffStep: 1 },
  C: { alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789.,?!:;'-()/@#&", mStepDiv: 7, lStepDiv: 11, roffStep: 2 },
  D: { alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789.,?!:;'-()/@#&âˆ†Î£Î Î¦Î©Î›Î˜Î“Î¨Î›Î¨ðŸ™ƒðŸ˜ŠðŸŒŸðŸ”¥ðŸ’§â„ï¸", mStepDiv: 7, lStepDiv: 11, roffStep: 1 },
};
function buildSig2Map(alpha){
  const map = new Map();
  for(let i=0;i<alpha.length;i++) map.set(alpha[i], i);
  return map;
}
function cleanSIG2Text(s, map){
  const up = (s||"").toUpperCase();
  let out="";
  for(const ch of up){
    if(map.has(ch)) out+=ch;
  }
  return out;
}
async function buildSIG2(key, nonce, salt, mode){
  const cfg = SIG2_MODES[mode] || SIG2_MODES.A;
  const alpha = cfg.alphabet;
  const stream = byteStreamFromString(`SIG2|${key.trim()}|${salt||""}|${nonce}|MODE:${mode}|ALPHA:${alpha}`);
  const nextByte = async()=> (await stream.next()).value;

  async function randInt(n){
    const lim = Math.floor(256/n)*n;
    while(true){
      const b = await nextByte();
      if(b < lim) return b % n;
    }
  }
  async function makePerm(n){
    const arr = Array.from({length:n},(_,i)=>i);
    for(let i=n-1;i>0;i--){
      const j = await randInt(i+1);
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }
  const N = alpha.length;
  const r0=await makePerm(N), r1=await makePerm(N), r2=await makePerm(N);
  const inv = (r)=>{ const ir=new Array(N); for(let i=0;i<N;i++) ir[r[i]]=i; return ir; };
  const ir0=inv(r0), ir1=inv(r1), ir2=inv(r2);

  async function makeRef(){
    const ref = new Array(N).fill(-1);
    const u = Array.from({length:N},(_,i)=>i);
    while(u.length){
      const a = u.splice(await randInt(u.length),1)[0];
      if((await randInt(100))<15 || !u.length){ ref[a]=a; continue; }
      const b = u.splice(await randInt(u.length),1)[0];
      ref[a]=b; ref[b]=a;
    }
    return ref;
  }
  const ref=await makeRef();
  const o0=(await nextByte())%N, o1=(await nextByte())%N, o2=(await nextByte())%N;
  const roff=(await nextByte())%N;
  return {cfg,alpha,r0,r1,r2,ir0,ir1,ir2,ref,o0,o1,o2,roff};
}
function stepSIG2(state){
  const N = state.alpha.length;
  const cfg = state.cfg;
  state.o2 = (state.o2 + 1) % N;
  state.roff = (state.roff + cfg.roffStep) % N;
  if(state.o2 === 0 || (state.o2 % cfg.mStepDiv) === 0){
    state.o1 = (state.o1 + 1) % N;
  }
  if(state.o1 === 0 || (state.o1 % cfg.lStepDiv) === 0){
    state.o0 = (state.o0 + 1) % N;
  }
}
function rotorFwdN(x, rotor, off, N){ const y = rotor[(x+off)%N]; return (y - off + N)%N; }
function rotorInvN(x, ir, off, N){ const y = ir[(x+off)%N]; return (y - off + N)%N; }
function reflectN(x, ref, roff, N){ return (ref[(x+roff)%N] - roff + N)%N; }

async function sig2Crypt(key, nonce, salt, mode, text){
  const state = await buildSIG2(key, nonce, salt, mode);
  const alpha = state.alpha;
  const map = buildSig2Map(alpha);
  let out = "";
  const input = cleanSIG2Text(text, map);
  for(const ch of input){
    stepSIG2(state);
    const idx = map.get(ch);
    let x = idx;
    x = rotorFwdN(x, state.r0, state.o0, alpha.length);
    x = rotorFwdN(x, state.r1, state.o1, alpha.length);
    x = rotorFwdN(x, state.r2, state.o2, alpha.length);
    x = reflectN(x, state.ref, state.roff, alpha.length);
    x = rotorInvN(x, state.ir2, state.o2, alpha.length);
    x = rotorInvN(x, state.ir1, state.o1, alpha.length);
    x = rotorInvN(x, state.ir0, state.o0, alpha.length);
    out += alpha[x];
  }
  return out;
}
async function sig2Tag6(key, nonce, salt, mode, normalized){
  const cfg = SIG2_MODES[mode] || SIG2_MODES.A;
  const alpha = cfg.alphabet;
  const bytes = await sha256Bytes(`SIG2|TAG|${key.trim()}|${salt||""}|${nonce}|${mode}|${alpha}|${normalized}`);
  return bytesToHex(bytes).slice(0,6).toUpperCase();
}

/* =========================
   SIG3 Draft Engine
========================= */
const SIG3_ALPHABET =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
  " " +
  "0123456789" +
  ".,?!:;'-()/" +
  "@#&";

const SIG3_ALPHABET_D =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
  " " +
  "0123456789" +
  ".,?!:;'-()/" +
  "@#&" +
  "Î”Î©Î£Ï€Î»â˜…â˜†âœ“âœ—â™¥â™¦â™£â™ " +
  "ðŸ™‚ðŸ˜ˆðŸ‘½ðŸš€ðŸ›°ï¸ðŸ§©ðŸ”’ðŸ”¥â„ï¸";

const SIG3_MODES = {
  A: { stepping:"standard", reflector:"standard", alphabet: SIG3_ALPHABET },
  B: { stepping:"aggressive", reflector:"standard", alphabet: SIG3_ALPHABET },
  C: { stepping:"standard", reflector:"alt",      alphabet: SIG3_ALPHABET },
  D: { stepping:"standard", reflector:"standard", alphabet: SIG3_ALPHABET_D },
};
const KDF_LEVELS = {
  0: { iterations: 1 },
  1: { iterations: 20000 },
  2: { iterations: 100000 },
  3: { iterations: 300000 },
};
const modN = (n,N)=> (n%N + N)%N;

function makeIndexMap(alpha){
  const m=new Map();
  for(let i=0;i<alpha.length;i++) m.set(alpha[i], i);
  return m;
}
function cleanSIG3Text(s, map){
  const t=(s||"").toUpperCase();
  let out="";
  for(const ch of t){
    if(map.has(ch)) out += ch;
  }
  return out;
}
async function pbkdf2Bytes(passwordStr, saltStr, iterations, bytesLen){
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    enc.encode(passwordStr),
    "PBKDF2",
    false,
    ["deriveBits"]
  );
  const bits = await crypto.subtle.deriveBits(
    { name:"PBKDF2", hash:"SHA-256", salt: enc.encode(saltStr), iterations },
    keyMaterial,
    bytesLen * 8
  );
  return new Uint8Array(bits);
}
async function sig3SeedBytes({key, salt, nonce, mode, kdfLevel, date, alphabet}){
  const k = (key||"").trim();
  const s = (salt||"").trim();
  const d = (date||"").trim();
  const m = (mode||"A").toUpperCase();
  const seedStr = `SIG3|${m}|${k}|SALT:${s}|NONCE:${nonce}|DATE:${d}|ALPHA:${alphabet}`;

  if(String(kdfLevel) === "0"){
    return await sha256Bytes(seedStr);
  }
  const it = (KDF_LEVELS[kdfLevel] || KDF_LEVELS[2]).iterations;
  return await pbkdf2Bytes(`SIG3|${k}|${s}`, `NONCE:${nonce}|MODE:${m}|DATE:${d}|ALPHA:${alphabet}`, it, 32);
}
async function buildSIG3Machine({key, salt, nonce, mode, kdfLevel, date, alphabet, reflectorVariant}){
  if(!key || !key.trim()) throw new Error("Key required.");
  const N = alphabet.length;

  const seed = await sig3SeedBytes({key, salt, nonce, mode, kdfLevel, date, alphabet});
  const stream = byteStreamFromBytes(seed);
  const nextByte = async()=> (await stream.next()).value;

  async function randInt(n){
    const lim = Math.floor(256/n)*n;
    while(true){
      const b = await nextByte();
      if(b < lim) return b % n;
    }
  }
  async function makePerm(){
    const arr = Array.from({length:N},(_,i)=>i);
    for(let i=N-1;i>0;i--){
      const j = await randInt(i+1);
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }
  function invPerm(r){
    const ir=new Array(N);
    for(let i=0;i<N;i++) ir[r[i]]=i;
    return ir;
  }
  async function makeReflector(kind){
    const fixedRate = (kind==="alt") ? 8 : 15;
    const ref=new Array(N).fill(-1);
    const u=Array.from({length:N},(_,i)=>i);
    while(u.length){
      const a = u.splice(await randInt(u.length),1)[0];
      if((await randInt(100)) < fixedRate || !u.length){ ref[a]=a; continue; }
      const b = u.splice(await randInt(u.length),1)[0];
      ref[a]=b; ref[b]=a;
    }
    return ref;
  }

  const r0=await makePerm(), r1=await makePerm(), r2=await makePerm();
  const ir0=invPerm(r0), ir1=invPerm(r1), ir2=invPerm(r2);
  const ref = await makeReflector(reflectorVariant || "standard");

  const o0=(await nextByte())%N, o1=(await nextByte())%N, o2=(await nextByte())%N;
  const roff=(await nextByte())%N;
  return {N, alphabet, r0,r1,r2, ir0,ir1,ir2, ref, o0,o1,o2, roff};
}
function stepSIG3(s, stepping){
  const N=s.N;
  s.o2 = (s.o2 + 1) % N;
  s.roff = (s.roff + 1) % N;
  if(stepping === "aggressive"){
    if(s.o2 === 0 || (s.o2 % 5) === 0) s.o1 = (s.o1 + 1) % N;
    if(s.o1 === 0 || (s.o1 % 7) === 0) s.o0 = (s.o0 + 1) % N;
  }else{
    if(s.o2 === 0 || (s.o2 % 7) === 0) s.o1 = (s.o1 + 1) % N;
    if(s.o1 === 0 || (s.o1 % 11) === 0) s.o0 = (s.o0 + 1) % N;
  }
}
function rotorFwdNN(x, rotor, off, N){
  const y = rotor[modN(x + off, N)];
  return modN(y - off, N);
}
function rotorInvNN(x, invRotor, off, N){
  const y = invRotor[modN(x + off, N)];
  return modN(y - off, N);
}
function reflectNN(x, ref, roff, N){
  return modN(ref[modN(x + roff, N)] - roff, N);
}
function xformSIG3(x, s){
  const N=s.N;
  x = rotorFwdNN(x, s.r0, s.o0, N);
  x = rotorFwdNN(x, s.r1, s.o1, N);
  x = rotorFwdNN(x, s.r2, s.o2, N);
  x = reflectNN(x, s.ref, s.roff, N);
  x = rotorInvNN(x, s.ir2, s.o2, N);
  x = rotorInvNN(x, s.ir1, s.o1, N);
  x = rotorInvNN(x, s.ir0, s.o0, N);
  return x;
}
async function sig3Crypt({key, salt, nonce, mode, kdfLevel, date, text, alphabet, stepping, reflectorVariant}){
  const map = makeIndexMap(alphabet);
  const input = cleanSIG3Text(text, map);
  if(!input) return "";
  const s = await buildSIG3Machine({key, salt, nonce, mode, kdfLevel, date, alphabet, reflectorVariant});
  let out="";
  for(const ch of input){
    stepSIG3(s, stepping);
    const idx = map.get(ch);
    const y = xformSIG3(idx, s);
    out += alphabet[y];
  }
  return out;
}
async function sig3Tag6({key, salt, nonce, mode, kdfLevel, date, alphabet, normalizedPlain}){
  const k=(key||"").trim(), s=(salt||"").trim(), d=(date||"").trim(), m=(mode||"A").toUpperCase();
  const bytes = await sha256Bytes(`SIG3|TAG|KDF:${kdfLevel}|${m}|${k}|SALT:${s}|NONCE:${nonce}|DATE:${d}|ALPHA:${alphabet}|${normalizedPlain}`);
  return bytesToHex(bytes).slice(0,6).toUpperCase();
}

/* Packed */
function b64urlEncode(bytes){
  let bin="";
  for(const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
}
function b64urlDecode(str){
  const s = (str||"").replace(/-/g,"+").replace(/_/g,"/");
  const pad = s.length % 4 ? "=".repeat(4 - (s.length % 4)) : "";
  const bin = atob(s+pad);
  const out = new Uint8Array(bin.length);
  for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i);
  return out;
}
function packIndices(text, alphabet){
  const N = alphabet.length;
  if(N > 64) return null;
  const map = makeIndexMap(alphabet);
  const cleaned = cleanSIG3Text(text, map);
  const idxs = [];
  for(const ch of cleaned) idxs.push(map.get(ch));
  const len = idxs.length;
  if(len > 65535) throw new Error("Message too long to pack.");
  const bitsTotal = len * 6;
  const bytesLen = Math.ceil(bitsTotal / 8);
  const out = new Uint8Array(2 + bytesLen);
  out[0] = (len >> 8) & 255;
  out[1] = len & 255;
  let bitPos = 0;
  for(const v of idxs){
    for(let k=5;k>=0;k--){
      const bit = (v >> k) & 1;
      const byteIndex = 2 + (bitPos >> 3);
      const bitIndex = 7 - (bitPos & 7);
      out[byteIndex] |= (bit << bitIndex);
      bitPos++;
    }
  }
  return "P:" + b64urlEncode(out);
}
function unpackIndices(packed, alphabet){
  const N = alphabet.length;
  if(N > 64) throw new Error("Packed decoding not supported for this alphabet.");
  if(!packed.startsWith("P:")) throw new Error("Not a packed segment.");
  const bytes = b64urlDecode(packed.slice(2));
  if(bytes.length < 2) throw new Error("Packed data too short.");
  const len = (bytes[0] << 8) | bytes[1];
  const bitsTotal = len * 6;
  const needed = 2 + Math.ceil(bitsTotal/8);
  if(bytes.length < needed) throw new Error("Packed data truncated.");
  let bitPos = 0;
  let out = "";
  for(let i=0;i<len;i++){
    let v=0;
    for(let k=0;k<6;k++){
      const byteIndex = 2 + (bitPos >> 3);
      const bitIndex = 7 - (bitPos & 7);
      const bit = (bytes[byteIndex] >> bitIndex) & 1;
      v = (v<<1) | bit;
      bitPos++;
    }
    if(v >= N) throw new Error("Packed index out of range.");
    out += alphabet[v];
  }
  return out;
}

/* Stego */
function stegoWrap(style, payload){
  if(!payload) return "";
  const short = payload.length > 48 ? (payload.slice(0,24) + "â€¦" + payload.slice(-18)) : payload;
  if(style === "version") return `v3.0.${Math.floor(Math.random()*90)+10}-notes (${short})`;
  if(style === "coords"){
    const lat = (Math.random()*180-90).toFixed(5);
    const lon = (Math.random()*360-180).toFixed(5);
    return `GPS ${lat}, ${lon} // ref=${payload}`;
  }
  if(style === "commit"){
    const fake = bytesToHex(crypto.getRandomValues(new Uint8Array(10))).slice(0,12);
    return `build ${fake} - ${payload}`;
  }
  return payload;
}

/* Inspector */
let inspectorOn = false;
function setInspector(on){
  inspectorOn = !!on;
  el("inspectorPanel").classList.toggle("hidden", !inspectorOn);
  el("inspectorBadge").textContent = inspectorOn ? "Inspector: on" : "Inspector: off";
}
function setDebug(text){
  if(!inspectorOn) return;
  el("insDebug").value = text || "";
}

/* =========================
   UI wiring
========================= */
function setVersion(v){
  el("tabSIG1").classList.toggle("active", v==="SIG1");
  el("tabSIG2").classList.toggle("active", v==="SIG2");
  el("tabSIG3").classList.toggle("active", v==="SIG3");
  el("panelSIG1").style.display = v==="SIG1" ? "" : "none";
  el("panelSIG2").style.display = v==="SIG2" ? "" : "none";
  el("panelSIG3").style.display = v==="SIG3" ? "" : "none";
}
el("tabSIG1").addEventListener("click", ()=>setVersion("SIG1"));
el("tabSIG2").addEventListener("click", ()=>setVersion("SIG2"));
el("tabSIG3").addEventListener("click", ()=>setVersion("SIG3"));

function setSIG1Mode(m){
  el("tabSIG1Dec").classList.toggle("active", m==="dec");
  el("tabSIG1Enc").classList.toggle("active", m==="enc");
  el("sig1Dec").style.display = m==="dec" ? "" : "none";
  el("sig1Enc").style.display = m==="enc" ? "" : "none";
}
el("tabSIG1Dec").addEventListener("click", ()=>setSIG1Mode("dec"));
el("tabSIG1Enc").addEventListener("click", ()=>setSIG1Mode("enc"));

function setSIG2ModePanel(m){
  el("tabSIG2Dec").classList.toggle("active", m==="dec");
  el("tabSIG2Enc").classList.toggle("active", m==="enc");
  el("sig2Dec").style.display = m==="dec" ? "" : "none";
  el("sig2Enc").style.display = m==="enc" ? "" : "none";
}
el("tabSIG2Dec").addEventListener("click", ()=>setSIG2ModePanel("dec"));
el("tabSIG2Enc").addEventListener("click", ()=>setSIG2ModePanel("enc"));

function setSIG3Mode(m){
  el("tabSIG3Dec").classList.toggle("active", m==="dec");
  el("tabSIG3Enc").classList.toggle("active", m==="enc");
  el("sig3Dec").style.display = m==="dec" ? "" : "none";
  el("sig3Enc").style.display = m==="enc" ? "" : "none";
}
el("tabSIG3Dec").addEventListener("click", ()=>setSIG3Mode("dec"));
el("tabSIG3Enc").addEventListener("click", ()=>setSIG3Mode("enc"));

/* Inspector hotkey */
document.addEventListener("keydown", (e)=>{
  if(e.ctrlKey && e.shiftKey && (e.key==="S" || e.key==="s")){
    e.preventDefault();
    setInspector(!inspectorOn);
  }
});

/* ---- SIG1 actions ---- */
el("sig1BtnNonce").addEventListener("click", ()=>{ el("sig1Nonce").value = nonce6(); });
el("sig1BtnEnc").addEventListener("click", async()=>{
  try{
    el("sig1StatusEnc").textContent = "";
    const key = el("key").value || "";
    let nonce = cleanAZ(el("sig1Nonce").value || "");
    if(nonce.length !== 6){ nonce = nonce6(); el("sig1Nonce").value = nonce; }
    const pt = el("sig1Plain").value || "";
    const ct = await sig1Crypt(key, nonce, pt);
    el("sig1Cipher").value = ct;
    el("sig1PayloadOut").value = `SIG1.${nonce}.${ct}`;
    el("sig1StatusEnc").innerHTML = `<span class="ok">Encrypted</span> â€¢ Len: ${ct.length}`;
  }catch(e){
    el("sig1StatusEnc").innerHTML = `<span class="err">${e.message}</span>`;
  }
});
el("sig1BtnCopyPayload").addEventListener("click", ()=>copyText(el("sig1PayloadOut").value));
el("sig1BtnCopyClean").addEventListener("click", ()=>copyText(el("sig1OutClean").value));
el("sig1BtnDec").addEventListener("click", async()=>{
  try{
    el("sig1Status").textContent = "";
    const key = el("key").value || "";
    const raw = extractPayload(el("sig1Payload").value || "").toUpperCase();
    const parts = raw.split(".");
    if(parts.length !== 3 || parts[0] !== "SIG1") throw new Error("Expected: SIG1.<NONCE6>.<CIPHERTEXT>");
    const nonce = cleanAZ(parts[1]);
    const ct = cleanSIG1Text(parts.slice(2).join("."));
    if(nonce.length !== 6) throw new Error("SIG1 nonce must be 6 letters.");
    const pt = await sig1Crypt(key, nonce, ct);
    el("sig1OutRaw").value = pt;
    el("sig1OutClean").value = pt.replace(/X/g," ");
    el("sig1Status").innerHTML = `<span class="ok">Decrypted</span> â€¢ Len: ${pt.length}`;
  }catch(e){
    el("sig1Status").innerHTML = `<span class="err">${e.message}</span>`;
  }
});
el("sig1BtnClear").addEventListener("click", ()=>{
  el("sig1Payload").value = "";
  el("sig1OutRaw").value = "";
  el("sig1OutClean").value = "";
  el("sig1Status").textContent = "";
});

/* ---- SIG2 actions ---- */
el("sig2BtnNonce").addEventListener("click", ()=>{ el("sig2Nonce").value = nonce6(); });
el("sig2BtnEnc").addEventListener("click", async ()=>{
  try{
    el("sig2StatusEnc").textContent="";
    const key = el("key").value || "";
    let nonce = cleanAZ(el("sig2Nonce").value || "");
    if(nonce.length !== 6){ nonce = nonce6(); el("sig2Nonce").value = nonce; }
    const salt = el("sig2SaltEnc").value || "";
    const mode = el("sig2ModeEnc").value || "A";
    const plainRaw = el("sig2Plain").value || "";
    const cfg = SIG2_MODES[mode] || SIG2_MODES.A;
    const map = buildSig2Map(cfg.alphabet);
    const plainNorm = cleanSIG2Text(plainRaw, map);
    if(!plainNorm) throw new Error("Plaintext is empty after cleaning.");
    const ct = await sig2Crypt(key, nonce, salt, mode, plainNorm);
    const tag = await sig2Tag6(key, nonce, salt, mode, plainNorm);
    el("sig2Cipher").value = ct;
    el("sig2Tag").value = tag;
    el("sig2PayloadOut").value = `SIG2${mode}.${nonce}.${tag}.${ct}`;
    el("sig2StatusEnc").innerHTML = `<span class="ok">Encrypted</span> â€¢ Len: ${ct.length}`;
  }catch(e){
    el("sig2StatusEnc").innerHTML = `<span class="err">${e.message}</span>`;
  }
});
el("sig2BtnCopyPayload").addEventListener("click", ()=>copyText(el("sig2PayloadOut").value));
el("sig2BtnCopyPlain").addEventListener("click", ()=>copyText(el("sig2Out").value));

el("sig2BtnDec").addEventListener("click", async ()=>{
  try{
    el("sig2Status").textContent="";
    const key = el("key").value || "";
    const raw = (el("sig2Payload").value || "").trim().toUpperCase().replace(/\s+/g,"");
    const parts = raw.split(".");
    if(parts.length < 4 || !parts[0].startsWith("SIG2")) throw new Error("Expected: SIG2<MODE>.<NONCE6>.<TAG6>.<CIPHERTEXT>");
    const prefix = parts[0];
    const mode = prefix.length > 4 ? prefix.substring(4,5) : "A";
    const nonce = cleanAZ(parts[1]);
    const tag = (parts[2]||"").toUpperCase();
    const ct = parts.slice(3).join(".");
    if(nonce.length !== 6) throw new Error("Nonce must be 6 letters.");

    const salt = el("sig2SaltDec").value || "";
    el("sig2ModeDec").value = mode;

    const cfg = SIG2_MODES[mode] || SIG2_MODES.A;
    const map = buildSig2Map(cfg.alphabet);

    const pt = await sig2Crypt(key, nonce, salt, mode, ct);
    el("sig2Out").value = pt;

    const ptNorm = cleanSIG2Text(pt, map);
    const check = await sig2Tag6(key, nonce, salt, mode, ptNorm);

    if(check === tag){
      el("sig2Status").innerHTML = `<span class="ok">Decrypted â€¢ Tag OK</span> â€¢ Len: ${pt.length}`;
    }else{
      el("sig2Status").innerHTML = `<span class="warn">Decrypted but TAG FAILED</span> â€” wrong key, wrong salt, or modified message. Expected <span class="mono">${check}</span>, got <span class="mono">${tag}</span>.`;
    }
  }catch(e){
    el("sig2Status").innerHTML = `<span class="err">${e.message}</span>`;
  }
});
el("sig2BtnClear").addEventListener("click", ()=>{
  el("sig2Payload").value="";
  el("sig2Out").value="";
  el("sig2Status").textContent="";
  el("sig2ModeDec").value="";
});

/* ---- SIG3 actions ---- */
el("sig3BtnNonce").addEventListener("click", ()=>{ el("sig3Nonce").value = nonce6(); });

function sig3GetAlphabet(mode){
  const m = (mode||"A").toUpperCase();
  return (SIG3_MODES[m] || SIG3_MODES.A).alphabet;
}
function sig3GetStepping(mode){
  const m = (mode||"A").toUpperCase();
  return (SIG3_MODES[m] || SIG3_MODES.A).stepping;
}
function sig3GetReflector(mode){
  const m = (mode||"A").toUpperCase();
  return (SIG3_MODES[m] || SIG3_MODES.A).reflector;
}

function buildSIG3Payload({mode, nonce, kdf, date, tag, tagDecoy, ct, ctDecoy}){
  const d = date && date.trim() ? date.trim() : "--------";
  const kd = String(kdf ?? "2");
  if(tagDecoy && ctDecoy){
    return `SIG3${mode}.${nonce}.${kd}.${d}.${tag}.${tagDecoy}.${ct}.${ctDecoy}`;
  }
  return `SIG3${mode}.${nonce}.${kd}.${d}.${tag}.${ct}`;
}

function parseSIG3Payload(text){
  const raw = extractPayload(text||"").trim();
  const up = raw.toUpperCase().replace(/\s+/g,"");
  const parts = up.split(".");
  if(parts.length < 6 || !parts[0].startsWith("SIG3")) throw new Error("Expected SIG3 payload.");
  const prefix = parts[0];
  const mode = prefix.length > 4 ? prefix.substring(4,5) : "A";
  const nonce = cleanAZ(parts[1]);
  const kdf = parts[2] || "2";
  const date = parts[3] || "--------";
  if(nonce.length !== 6) throw new Error("Nonce must be 6 letters.");

  if(parts.length >= 8){
    return {
      mode,
      nonce,
      kdf,
      date,
      tag: parts[4],
      tagDecoy: parts[5],
      ct: parts[6],
      ctDecoy: parts.slice(7).join("."),
      hasDecoy: true,
      raw: up
    };
  }
  return {
    mode,
    nonce,
    kdf,
    date,
    tag: parts[4],
    ct: parts.slice(5).join("."),
    hasDecoy: false,
    raw: up
  };
}

async function sig3EncryptOne({key, salt, nonce, mode, kdfLevel, date, plain, outFmt}){
  const alphabet = sig3GetAlphabet(mode);
  const stepping = sig3GetStepping(mode) === "aggressive" ? "aggressive" : "standard";
  const reflectorVariant = sig3GetReflector(mode) === "alt" ? "alt" : "standard";
  const map = makeIndexMap(alphabet);
  const plainNorm = cleanSIG3Text(plain, map);
  if(!plainNorm) throw new Error("Plaintext is empty after cleaning.");

  const ctFull = await sig3Crypt({
    key, salt, nonce, mode, kdfLevel, date,
    text: plainNorm,
    alphabet,
    stepping,
    reflectorVariant
  });

  const tag = await sig3Tag6({
    key, salt, nonce, mode, kdfLevel, date,
    alphabet,
    normalizedPlain: plainNorm
  });

  let ctOut = ctFull;
  if(outFmt === "packed"){
    const packed = packIndices(ctFull, alphabet);
    if(packed) ctOut = packed;
  }

  return {alphabet, plainNorm, ctFull, ctOut, tag};
}

async function sig3DecryptOne({key, salt, nonce, mode, kdfLevel, date, ctSeg}){
  const alphabet = sig3GetAlphabet(mode);
  const stepping = sig3GetStepping(mode) === "aggressive" ? "aggressive" : "standard";
  const reflectorVariant = sig3GetReflector(mode) === "alt" ? "alt" : "standard";
  let ct = ctSeg;

  if(typeof ct === "string" && ct.startsWith("P:")){
    ct = unpackIndices(ct, alphabet);
  }

  const pt = await sig3Crypt({
    key, salt, nonce, mode, kdfLevel, date,
    text: ct,
    alphabet,
    stepping,
    reflectorVariant
  });
  return {alphabet, pt};
}

el("sig3BtnEnc").addEventListener("click", async ()=>{
  try{
    el("sig3StatusEnc").textContent = "";
    const key = el("key").value || "";
    let nonce = cleanAZ(el("sig3Nonce").value || "");
    if(nonce.length !== 6){ nonce = nonce6(); el("sig3Nonce").value = nonce; }

    const mode = el("sig3ModeEnc").value || "A";
    const salt = el("sig3SaltEnc").value || "";
    const kdf = el("sig3KdfEnc").value || "2";
    const date = (el("sig3DateEnc").value || "").trim();
    const outFmt = el("sig3OutFmt").value || "standard";

    const realPlain = el("sig3Plain").value || "";
    const decoyPlain = (el("sig3PlainDecoy").value || "").trim();
    const decoySalt = el("sig3SaltDecoy").value || "";

    const real = await sig3EncryptOne({key, salt, nonce, mode, kdfLevel:kdf, date, plain: realPlain, outFmt});

    let payload = "";
    if(decoyPlain){
      const dec = await sig3EncryptOne({key, salt:decoySalt, nonce, mode, kdfLevel:kdf, date, plain: decoyPlain, outFmt});
      el("sig3Tag").value = real.tag;
      el("sig3TagDecoy").value = dec.tag;
      payload = buildSIG3Payload({
        mode, nonce, kdf, date,
        tag: real.tag,
        tagDecoy: dec.tag,
        ct: real.ctOut,
        ctDecoy: dec.ctOut
      });
    }else{
      el("sig3Tag").value = real.tag;
      el("sig3TagDecoy").value = "";
      payload = buildSIG3Payload({
        mode, nonce, kdf, date,
        tag: real.tag,
        ct: real.ctOut
      });
    }

    el("sig3PayloadOut").value = payload;

    const stegoStyle = el("sig3StegoStyle").value || "none";
    el("sig3StegoOut").value = stegoStyle === "none" ? "" : stegoWrap(stegoStyle, payload);

    el("sig3StatusEnc").innerHTML = `<span class="ok">Encrypted</span> â€¢ Len: ${real.ctFull.length}${decoyPlain ? " â€¢ Decoy: yes" : ""}`;
  }catch(e){
    el("sig3StatusEnc").innerHTML = `<span class="err">${e.message}</span>`;
  }
});

el("sig3BtnCopyPayload").addEventListener("click", ()=>copyText(el("sig3PayloadOut").value));
el("sig3BtnCopyStego").addEventListener("click", ()=>copyText(el("sig3StegoOut").value));
el("sig3BtnCopyPlain").addEventListener("click", ()=>copyText(el("sig3Out").value));

el("sig3BtnDec").addEventListener("click", async ()=>{
  try{
    el("sig3Status").textContent = "";
    setDebug("");

    const key = el("key").value || "";
    const salt = el("sig3SaltDec").value || "";
    const ignoreTime = inspectorOn && el("insIgnoreTime").value === "1";

    const parsed = parseSIG3Payload(el("sig3Payload").value || "");
    const mode = el("sig3ModeDec").value || parsed.mode || "A";
    const nonce = parsed.nonce;
    const kdf = el("sig3KdfDec").value || parsed.kdf || "2";
    const date = (parsed.date && parsed.date !== "--------") ? parsed.date : "";

    if(date && isDate8(date) && !ignoreTime){
      const today = todayYYYYMMDD();
      if(date > today){
        throw new Error(`Time-locked until ${date} (today is ${today}).`);
      }
    }

    const real = await sig3DecryptOne({key, salt, nonce, mode, kdfLevel:kdf, date, ctSeg: parsed.ct});
    const alphabet = real.alphabet;

    const map = makeIndexMap(alphabet);
    const ptNorm = cleanSIG3Text(real.pt, map);
    const check = await sig3Tag6({key, salt, nonce, mode, kdfLevel:kdf, date, alphabet, normalizedPlain: ptNorm});

    let debug = `mode=${mode}\nnonce=${nonce}\nkdf=${kdf}\ndate=${date||"(none)"}\nct=${parsed.ct.slice(0,120)}${parsed.ct.length>120?"â€¦":""}\n`;
    debug += `tag_payload=${parsed.tag}\ntag_calc=${check}\n`;

    if(check !== parsed.tag && parsed.hasDecoy){
      const decSalt = el("sig3SaltDecoy").value || "";
      const dec = await sig3DecryptOne({key, salt:decSalt, nonce, mode, kdfLevel:kdf, date, ctSeg: parsed.ctDecoy});
      const mapD = makeIndexMap(dec.alphabet);
      const ptNormD = cleanSIG3Text(dec.pt, mapD);
      const checkD = await sig3Tag6({key, salt:decSalt, nonce, mode, kdfLevel:kdf, date, alphabet:dec.alphabet, normalizedPlain: ptNormD});
      debug += `\n(decoy attempt)\ndecoy_salt=${decSalt||"(empty)"}\ntag_payload_decoy=${parsed.tagDecoy}\ntag_calc_decoy=${checkD}\n`;

      if(checkD === parsed.tagDecoy){
        el("sig3Out").value = dec.pt;
        el("sig3Status").innerHTML = `<span class="ok">Decrypted â€¢ Decoy matched</span> â€¢ Len: ${dec.pt.length}`;
        setDebug(debug);
        return;
      }
    }

    el("sig3Out").value = real.pt;

    if(check === parsed.tag){
      el("sig3Status").innerHTML = `<span class="ok">Decrypted â€¢ Tag OK</span> â€¢ Len: ${real.pt.length}`;
    }else{
      el("sig3Status").innerHTML = `<span class="warn">Decrypted but TAG FAILED</span> â€” wrong key/salt/kdf/mode, time-lock mismatch, or modified message. Expected <span class="mono">${check}</span>, got <span class="mono">${parsed.tag}</span>.`;
    }

    setDebug(debug);
  }catch(e){
    el("sig3Status").innerHTML = `<span class="err">${e.message}</span>`;
    setDebug(String(e && e.stack ? e.stack : e));
  }
});

el("sig3BtnClear").addEventListener("click", ()=>{
  el("sig3Payload").value="";
  el("sig3Out").value="";
  el("sig3Status").textContent="";
  setDebug("");
});

/* =========================
   Initialize defaults
========================= */
el("sig1Nonce").value = nonce6();
el("sig2Nonce").value = nonce6();
el("sig3Nonce").value = nonce6();

el("insToday").value = todayYYYYMMDD();

setVersion("SIG1");
setSIG1Mode("dec");
setSIG2ModePanel("dec");
setSIG3Mode("dec");
setInspector(false);
</script>
</body>
</html>
